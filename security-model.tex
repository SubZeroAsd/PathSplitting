\section{Security and Privacy Model}
\label{sec:security-model}

\subsection{Preliminaries}
\label{sec:model-prelims}

We formalize the security and privacy notions of a multi-path payment channel network (MPPCN) 
and multi-path multi-hop locks (\sysname). We make use of the universal composability (UC) 
framework of Canetti \cite{canetti}.

\paragraph{Attacker Model}
We model parties as interactive Turing machines (ITMs), which communicate with a trusted 
functionality $\FF$ via secure and authenticated communication channels. We model the 
adversary $\sdv$ as a $\ppt$ machine that has access to an interface $\corrupt(\cdot)$, 
which takes as input a party identifier $P$ and provides the attacker with the internal 
state of $P$. From that point onward, all subsequent incoming and outgoing communication 
of $P$ is routed through $\sdv$. We consider the static corruption model, that is, the 
adversary is required to commit to the identifiers of the parties it wishes to corrupt 
ahead of time.

\paragraph{Communication Model}
Communication happens through the secure transmission functionality $\FF_{\smt}$, as 
defined in \cite{canetti}, which informs the adversary whenever a communication between 
any two parties happens, and allows the adversary to delay the delivery of the messages 
arbitrarily. However, the adversary can neither read nor change the content of the messages.

We consider a synchronous communication network, where communication proceeds in discrete 
rounds, as defined in \cite{kmtz} and denoted here as $\FF_{\syn}$ \MESSAGEP{We might want to use $\FF_{\textit{GDC}}$ instead from \url{https://eprint.iacr.org/2019/571.pdf}. The difference is: "In contrast to [19]($\FF_{\syn}$), we treat the clock functionality  as  a global ideal  functionality  using  the global  UC  (GUC) model"} \MESSAGEE{Sure, we can either use that one for time or stick to using the blockchain (again defined in GUC) as shown below. I guess we just need to decide what "time" really means for us. What I see from this paper is that the time they care about is for synchronous round communication, but we mainly use the time for timeouts of the transactions (of course we also assume there is some synchronous communication happening between parties). Hence, it feels to me that it makes more sense to use some kind of timing based on a blockchain for transactions. Or, we have to understand what exactly their time encompasses here. Can we use their clock to also model the timeouts of transactions?}. The parties are 
always aware of the current round, and if a party $P$ sends a message in round $r$, 
the recipient receives the message in the beginning of round $r + 1$. The 
adversary can change the order of messages, but we assume that the order of messages 
between honest parties cannot be changed (which can easily be realized using message 
counters). For simplicity, we assume that computation is instantaneous.

\TODOE{Figure out whether we actually need $\FF_{\anon}$ or not (currently we do not use it).}
%\MESSAGEP{Do we really need $\FF_{\anon}$?}
%\MESSAGEE{I think you use anonymous communication channel in your constructions in the CCS paper when senders sends data to the intermediaries and the receiver. Since the sender knows and prepares the whole path, you need to use it there to achieve any meaningful anonymity at all. However, in our case the sender does not know the whole path, so only talks with the receiver and its direct neighbors. Therefore, we may not need to use anonymous communication channel. But, we need to further discuss this to clarify what form of anonymity we are aiming for and achieving and whether we need anonymous communication channels to realize them.}
%Furthermore, we assume existence of an anonymous communication channel as defined in 
%\cite{cl}, which we denote here as $\FF_{\anon}$. In the ideal functionality we use the 
%interfaces send$_\smt$ and receive$_\smt$ to exchange messages through the $\FF_{\smt}$ 
%functionality, and interfaces send$_\anon$ and receive$_\anon$ to exchange messages via 
%$\FF_{\anon}$.

\paragraph{Ledger Functionality}
We assume existence of a blockchain $\BB$, modeled as a trusted append-only bulletin board. 
The corresponding ideal functionality $\FF_{\BB}$, as modeled in \cite{perun}, is used to 
store, read and update the balance of every user. It is defined in the 
global UC (GUC) model \cite{guc}, since it provides data that should be globally accessible, 
and it can be updated by multiple instances of our ideal functionality or by other protocols 
simultaneously. We denote the number of entries in $\BB$ as $|\BB|$, and we model time as the 
number of entries of the blockchain $\BB$ (i.e., time $t = |\BB|$).

\TODOE{Add interfaces for hybrid ideal functionalities and call these interfaces in our own ideal functionalities.}

\paragraph{Universal Composability}
We now review the notion of secure realization in the UC framework~\cite{canetti}. 
Intuitively, a protocol realizes an ideal functionality if the environment has no way 
to distinguish between the ideal functionality and the real-world protocol, where 
a simulator is in charge of translating the messages produced by the ideal functionality 
for the computational adversary. Here $\exec_{\pi, \adv, \dist}$ denotes the ensemble of 
the outputs of the environment $\dist$ when interacting with the adversary $\adv$ and 
users running protocol $\pi$.

\begin{definition}[Universal Composability]
A protocol $\pi$ UC-realizes an ideal functionality $\FF$ if for any $\ppt$ adversary 
$\adv$ there exists a simulator $\sdv$, such that for any environment $\dist$, the 
ensembles $\exec_{\pi, \adv, \dist}$ and $\exec_{\FF, \sdv, \dist}$ are computationally 
indistinguishable.
\end{definition}

\subsection{Multi-Path Payment Channel Network (MPPCN)}
\label{sec:mppcn}

In this section we define an ideal functionality $\FF_{\mathsf{MPPCN}}$ for MPPCNs. 
$\FF_{\mathsf{MPPCN}}$ works in interaction with a universe of users $\mathbb{U}$, which 
corresponds to the users of the PCN. To ease the exposition, we assume that there is a 
well-known ordering of the users in a sense that a user $U_i$ can only transact with user $U_j$ 
if $j > i$ for $i,j \in \NN$. For simplicity, we only consider unidirectional channels, 
however, we note that our functionality can be easily extended to support bidirectional 
channels. \MESSAGEP{We might want to do an intuitive argument of how to extend it or avoid this point.}\MESSAGEE{If we make use of an ideal functionality that implements bi-directional payment channel networks, then this becomes trivial, as we just use the interfaces of that ideal functionality for updates in both directions.} $\FF_{\mathsf{MPPCN}}$ makes use of $\FF_{\BB}$, $\FF_{\anon}$ and $\FF_{\syn}$, 
hence, it is defined in $(\FF_{\BB}, \FF_{\anon}, \FF_{\syn})$-hybrid model. Furthermore, 
$\FF_{\mathsf{MPPCN}}$ defines various data structures and operations explained below. 
Our ideal functionality $\FF_{\mathsf{MPPCN}}$ can be seen in \cref{fig:ideal-mppcn}.

\paragraph{Data Structures} 
In order to simplify the presentation of our ideal functionality, we define several data 
structures, where a data structure can be global or payment-specific. Global means that the 
data structure is initialized once and updated throughout the lifetime of the system, and it 
is available to every operation of the ideal functionality. On the other hand, payment-specific 
means that the ideal functionality initializes a new empty copy of the corresponding data 
structure with every new payment, and therefore, the data structure is only available to 
the payment operation. Our data structures are defined as follows:

\begin{itemize}
	\item Global data structures
	\begin{itemize}
		\item List $\CC$, which keeps track of all closed channels locally. The entries in $\CC$ 
		are of the form $c_{\langle U,U' \rangle}$, which corresponds to the channel identifier.
		\item List $\LL$, which records the off-chain payments locally. The entries in $\LL$ are 
		defined as $(c_{\langle U,U' \rangle}, v, t, h)$, where $c_{\langle U,U' \rangle}$ is the 
		corresponding channel identifier, $v$ is the amount of credit used, $t$ is the expiration 
		time of the payment, and $h$ is the identifier for this entry.
	\end{itemize}
	
	\item Payment-specific data structures
	\begin{itemize}
		\item List $\DD$, which records all off-chain transactions per multi-path payment. Each 
		entry of $\DD$ is indexed by a user identifier $U$, and the entries have the same format 
		as the entries of the list $\LL$. More precisely, $\DD[U]$ corresponds to all the 
		transactions in the current multi-path payment where $U$ is the payer of the transaction. 
		\item List $\HH$, which keeps track of off-chain payment identifiers. Similar to the list 
		$\DD$ it is also indexed by a user identifier, however, unlike list $\DD$ it does not 
		store the whole transaction data, and just stores the identifiers. More precisely, 
		$\HH[U]$ refers to all payment identifiers $h$ in the current multi-path payment, where 
		$U$ is the payer of the payment.
		\item List $\VV$, which keeps track of the amount of coins each user is supposed to 
		receive during a multi-path payment. Similar to lists $\DD$ and $\HH$ it is indexed 
		by a user identifier. The value $\VV[U]$ corresponds to the total amount of coins the 
		user $U$ is supposed to receive after a successful execution of a multi-pay payment.
		\item Set $\JJ$, which keeps track of the users who aborted during the execution of 
		a multi-path payment. Hence, it only stores the user identifiers.
	\end{itemize}
\end{itemize}
	
\paragraph{Operations}
In \cref{fig:ideal-mppcn} we describe the interactions between $\FF_{\mathsf{MPPCN}}$ and the 
users of the PCN. The execution starts with $\FF_{\mathsf{MPPCN}}$ initializing a local empty 
set $\CC$, and empty list $\LL$. Users of the PCN can query $\FF_{\mathsf{MPPCN}}$ on $\open$ 
interface to open new payment channels, and query on $\close$ interface to close them to any 
valid state that is in $\LL$. The multi-path payment operation is initiated with a call to 
$\mathsf{pay}$ interface by user $U_0$ (sender) on input a payment value $v$ and receiver 
identifier $U_{n+1}$. Then, $\FF_{\mathsf{MPPCN}}$ checks whether all the channels on the paths 
have enough capacity and whether the intermediaries allow the payments. If these conditions are 
satisfied $\FF_{\mathsf{MPPCN}}$ initiates the multi-path payment (step 1). Once the payment has 
reached the receiver, each user can again decide to interrupt the flow of the payment or not 
(step 2). Lastly, $\FF_{\mathsf{MPPCN}}$ informs the involved nodes that the operation was 
successful, and adds the updated channel states to $\LL$ (step 3).

\TODOE{Extend this part once we settle on the final version of the ideal functionality.}

\begin{figure*}[!t]
\centering
\fbox{\parbox{\textwidth}{
\TODOE{Add the fees to value calculations.}

%\textbf{Open Channel:} On input $(\open, \sid, c_{\langle U,U' \rangle}, v, U', t, f)$ from a 
%user $U$, $\FF$ checks whether $c_{\langle U,U' \rangle}$ is well-formed	 (i.e., contains valid 
%identifiers and it is not a duplicate), and sends $(c_{\langle U,U' \rangle}, v, t, f)$ 
%to $U'$ and $\sdv$, where $U'$ can either abort or authorize the operation. In the latter case, 
%$\FF$ appends the tuple $(c_{\langle U,U' \rangle}, v, t, f)$ to $\BB$ via $\FF_{\BB}$ and 
%$(c_{\langle U,U' \rangle}, v, t, h)$ to $\LL$, for some random $h$. Finally, $\FF$ sends $h$ 
%to $U, U'$ and $\sdv$. \\
%
%\textbf{Close Channel:} On input $(\close, \sid, c_{\langle U,U' \rangle}, h)$ from a user $U$ 
%or $U'$, the ideal functionality $\FF$ parses $\BB$ via $\FF_{\BB}$ for an entry 
%$(c_{\langle U,U' \rangle}, v, t, f)$ and $\LL$ for an entry $(c_{\langle U,U' \rangle}, v', t', 
%h)$ for $h \neq \bot$. If $c_{\langle U,U' \rangle} \in \CC$ or $t' > |\BB|$ or $t' > |\BB|$, 
%then $\FF$ aborts. Otherwise, $\FF$ adds the entry $(c_{\langle U,U' \rangle}, v', t')$ to 
%$\BB$ via $\FF_{\BB}$ and adds $c_{\langle U,U' \rangle}$ to $\CC$. Lastly, $\FF$ sends 
%$(c_{\langle U,U' \rangle}, \bot, h)$ to $U, U'$ and $\sdv$. \\

\textbf{Multi-Path Payment:} On input $(\mathsf{pay}, \sid, v, U_{n+1})$ from a user $U_0$, $\FF$ 
initializes the set $\JJ$ and lists $\DD, \HH, \VV$ as empty, sets $\VV[U_0] = v$, and executes 
the following interactive protocol:

\begin{enumerate}
	\item For all $i \in \{0,\ldots,n\}$, $\FF$ sets $v_i = \VV[U_i]$, sends $(\mathsf{split-}
	\mathsf{req}, \sid, \NEWE{U_{n+1}}, v_i)$ to $U_i$ and $\sdv$ \MESSAGEP{$\sdv$ would need to know $U_i$ also, right?} \TODOE{Ask Daniel about this.}, where $U_i$ replies with $(\mathsf{split}, 
	\sid, \{(U_i^1,v_i^1,t_i^1),\ldots,(U_i^{k_i},v_i^{k_i},t_i^{k_i})\})$ for $1 \leq k_i 
	\leq n$. If the set is empty, 
	then $\FF$ aborts. Otherwise, for all $j \in \{1,\ldots,k_i\}$, $\FF$ samples a 
	random $h_i^j$, and parses $\BB$ via $\FF_{\BB}$ for an entry of the form $(c_{\langle U_i,U_i^j \rangle}, 
	v^*, t^*, f^*)$.  If such an entry exists, then $\FF$ sends the tuple $(h_i^j, c_{\langle 
	U_i,U_i^j \rangle}, v_i^j, t_i^j)$ to the user $U_i^j$ \REMOVEE{via an anonymous communication 
	channel} and notifies $\sdv$, where $U_i^j$ replies either with $\top$ or $\bot$. In the 
	latter case, $\FF$ aborts. Otherwise, $\FF$ adds $h_i^j$ to $\HH[U_i^j]$, sets $\VV[U_i^j] 
	= \VV[U_i^j] + v_i^j$, and checks whether for all entries of the form $(c_{\langle U_i,U_i^j 
	\rangle}, v^*, \cdot, \cdot) \in \LL$, it holds that $v^* \geq v_i^j$. If this is the case 
	$\FF$ adds $d_i^j = (c_{\langle U_i,U_i^j \rangle},v^* - v_i^j, t_i^j, \bot)$ to $\DD[U_i]$, 
	where $(c_{\langle U_i,U_i^j \rangle}, v^*, \cdot, \cdot) \in \LL$ is the entry with the 
	lowest $v^*$. Lastly, if any of the conditions above is not met or $\VV[U_{n+1}] \neq v$, 
	then $\FF$ aborts.
	
	\item For all $i \in \{n+1,\ldots,1\}$, $\FF$ sends $U_i$ with $\HH[U_i]$ \REMOVEE{through an 
	anonymous communication channel}, and notifies $\sdv$. Each user can reply either with 
	$\top$ or $\bot$. If $U_i$ replies with $\bot$, then $\FF$ add $U_i$ to $\JJ$.
	
	\item For all $i \in \{n,\ldots,0\}$, $\FF$ parses the entries of $\DD[U_i]$ as 
	$d_i^j = (c_{\langle U_i,U_i^j \rangle}, v', t_i^j, \bot)$, and creates a set 
	$\mathcal{R}$, which is composed of all user identifiers $U_i^j$. Next, $\FF$ checks 
	whether $\mathcal{R} \subseteq \JJ$. If this is the case, then $\FF$ adds $U_i$ to $\JJ$, 
	and sends $(\bot, h_i^j)$ to $U_i$ and $\sdv$. Otherwise, $\FF$ updates $d_i^j$ as 
	$d_i^j = (c_{\langle U_i,U_i^j \rangle}, v', t_i^j, h_i^j)$, adds $d_i^j$ to $\LL$, and 
	sends $(\top, h_i^j)$ to $U_i$ and $\sdv$.
\end{enumerate}
}}

\TODOP{I didn't fully get all the details. Revisit}

\MESSAGEP{We wanted to \emph{merge} PCN and Lock functionalities, right?}
\MESSAGEE{If we include lock interfaces here, it means that a way to realize a PCN is through a protocol that realized the lock ideal functionality. We can either keep it more generic (like it is now) I guess.}

\caption{Ideal functionality $\FF_{\mathsf{MPPCN}}$ in the $(\FF_{\BB}, \FF_{\anon}, 
\FF_{\syn})$-hybrid model}
\label{fig:ideal-mppcn}
\end{figure*}

\subsubsection{Discussion}
\label{sec:mppcn-discussion}

We introduce and discuss the security and privacy notions of interest for our 
$\FF_{\mathsf{MPPCN}}$ functionality.

\paragraph{Balance Security}
Balance security roughly means that an intermediary receives \emph{at least} as many coins as 
it forwards, and that it can pull its coins as soon as \emph{at least} one of its right 
neighbors has pulled. We assume that the first part of this property is enforced by the 
environment by making sure that the when a user splits, it cannot split to a value more than it 
is supposed to receive. \TODOE{Use a wrapper around our ideal functionality to make sure that environment restricts certain actions.} The second part is achieved 
in step 3 of $\mathsf{pay}$ interface, which guarantees that the only way a payment will fail 
for a user is if all of its right neighbors have aborted. Hence, the user has no one right 
neighbor that pulled.

\paragraph{Value Privacy}
Value privacy means that the value of a transaction between two non-compromised users cannot 
be determined. Our ideal functionality achieves this property as it does not contact any user 
who does not lie in the payment path, and for each transaction only the involved parties are 
contacted. 
\MESSAGEP{Ideally, we should recall the definitions that we had for credit networks and adjust them for PCN. Source here: \url{https://www.ndss-symposium.org/wp-content/uploads/2017/09/04_3_2.pdf}}

\MESSAGEE{If the adversary is in both paths when a split happened, does he even know that both paths are part of the same payment? We can try to build value privacy and relationship anonymity based on this observation.}

\paragraph{Completeness}
Completeness means that the receiver cannot start pulling the coins before it has received 
enough transactions, whose sum amount equals the total coins he is supposed to receive by 
the sender. Our ideal functionality keeps track of the amount of coins each user in the 
multi-path payment will receive in the list $\VV$, and it performs a check in step 1 of 
$\mathsf{pay}$ interface to make sure that the amount of coins the receiver will receive equals 
the amount with which the sender invoked the $\mathsf{pay}$ interface. Hence, our ideal 
functionality achieves this property as well.

\paragraph{Relationship Anonymity}
Relationship anonymity roughly means that any two simultaneous payments over the same path (or 
multi-path) for the same value (and splitting in case of multi-path payment) are 
indistinguishable to the eyes of the intermediaries as long as there exists \emph{at least} 
one honest users in the path (or per path in case of multi-path payment). 
\MESSAGEP{As before with value privacy, it would be good to refer to that definition of credit networks and also the one in PCN (CCS'17)}
This is achieved by 
our ideal functionality as every intermediate user only receives a unique identifier for 
each payment, and such an identifier is independent from the identifiers of other users involved 
in the same payment.

\subsection{Multi-Path Multi-Hop Locks (MPMHL)}
\label{sec:mpmhl}

In the following we define an ideal functionality $\FF_{\mathsf{MPMHL}}$ for {\sysname}s, which 
models the cryptographic lock functionality. Similar to $\FF_{\mathsf{MPPCN}}$, our ideal 
functionality $\FF_{\mathsf{MPMHL}}$ also works in interaction with a universe of users 
$\mathbb{U}$.  Our $\FF_{\sysname}$ ideal functionality can be seen in \cref{fig:ideal-func}.
$\FF_{\mathsf{MPMHL}}$ makes use of $\FF_{\anon}, \FF_{\smt}$ and $\FF_{\syn}$, thus, it is 
defined in $(\FF_{\anon}, \FF_{\smt}, \FF_{\syn})$-hybrid model. The data structures and 
operations that $\FF_{\mathsf{MPMHL}}$ defines are shown below. Our ideal functionality 
$\FF_{\mathsf{MPMHL}}$ is found in \cref{fig:ideal-mpmhl}.

\paragraph{Data Structures}
Our ideal functionality uses the following data structures internally:

\begin{itemize}
	\item List $\LL$, which is initialized as empty list and is used to track the locks. 
	The entries of $\LL$ are of the form $(\lid_i, \td_i, U_i, U_j, f, \\ \lid_{i+1})$, 
	where $\lid_i$ is unique lock identifier, $\td_i$ is the trapdoor of the lock, $U_i$ 
	and $U_j$ are the users connected by the lock (the left and right user, respectively), 
	$f \in \{\Init,\Lock,\Rel\}$ is a status flag of the lock, and $\lid_{i+1}$ is the 
	identifier of the next lock on the path. We note that the trapdoors are only associated 
	to the initial locks created from the sender, and in all subsequent locks on the path the 
	trapdoor is set to $\bot$. However, since our list $\LL$ has a linked structure (includes 
	the next lock identifier), we can recursively traverse the list of locks on the path to 
	obtain the trapdoor associated to the path.
\end{itemize}

\paragraph{Operations}
In \cref{fig:ideal-mpmhl} we define the ideal functionality $\FF_{\mathsf{MPMHL}}$ with its 5 
interfaces. The $\Setup$ interface allows the user $U_0$ (the sender) to setup states and 
trapdoors to be used later when establishing and releasing the locks. The $\Lock$ interface 
allows a user to establish locks with its right neighbors using the previously established 
locks. The $\Extract$ interface allows the user $U_n$ (the receiver) to release the locks that it 
received using the initially created trapdoors. The $\Release$ interface allows an intermediate 
user along the path to release the locks with its left neighbors assuming its right locks are 
released. Lastly, $\mathsf{GetStatus}$ interface allows a user to check the current status of 
a lock. We note that internally the locks are assigned identifiers that are unique across all 
paths.

For ease of exposition we also define several functions that extract or update information of 
a lock given its identifier as input: $\getStatus(\cdot)$ returns the status of the lock, 
$\getLeft(\cdot)$ and $\getRight(\cdot)$ return the left and right user involved with the 
lock, $\getNextLock(\cdot)$ returns the identifier of the next lock, $\setRightUser(\cdot, U)$ 
sets the right user of the lock to a user $U$, $\setRightLock(\cdot, \lid)$ sets the right lock 
of the lock to $\lid$, $\updateStatus(\cdot, f)$ sets the status of the lock to a flag $f$, 
$\generateTrapdoor(\cdot)$ creates a trapdoor associated to the lock, and $\validateTrapdoors
((\cdots), (\td_1,\ldots,\td_m))$ checks that the trapdoors are associated to the given locks 
by recursively traversing the path of each given lock.

\begin{figure*}[!h]
	\centering
	
	\fbox{
		\begin{minipage}[t]{0.50\textwidth}
			\procedure[mode=text]{$\Setup(\sid, v, (U_0,U_n))$}{
				Upon invocation by $U_0$:  												\\
				$\forall i \in [1,v]$:													\\
				\quad $\lid_i \sample \{0, 1\}^\lambda$									\\
				\quad $\td_i \gets \generateTrapdoor(\lid_i)$							\\
				\quad insert $(\lid_i, \td_i, U_0, \bot, \Init, \bot)$ to $\LL$			\\
				send$_\anon$ $(\sid, ((\lid_1, \Init),\ldots,(\lid_v, \Init)))$ to $U_0$ and 
				$\sdv$																	\\
				send$_\anon$ $(\sid, v, (\td_1,\ldots,\td_v))$ to $U_n$ and $\sdv$
			}
			\\ \\
			\procedure[mode=text]{$\Release(\sid, (\lid_1,\ldots,\lid_k))$}{
				Upon invocation by $U_i$: 												\\
				$\forall i \in [1,k]$: 													\\
				\quad if $U_i = U_n$ or $\getRight(\lid_i) \neq U_i$ or 
				$\getStatus(\lid_i) \neq \Lock$ or $\getStatus(\getNextLock(\lid_i)) 
				\neq \Rel$	then send$_\smt$ $(\sid, \lid_i, \bot)$ to $U_i$	 and $\sdv$	\\
				\quad else:																\\
				\qquad $\updateStatus(\lid_i, \Rel)$										\\
				\qquad send$_\smt$ $(\sid, \lid_i, \Rel)$ to $\getLeft(\lid_i)$ and $\sdv$
			}
			\\
			\procedure[mode=text]{$\Extract(\sid, (\lid_1,\ldots,\lid_k),(\td_1,\ldots,\td_v))$}{
				Upon invocation by $U_n$:												\\
				$\forall i \in [1,k]$: if $\getRight(\lid_i) \neq U_n$ or 
				$\getStatus(\lid_i) \neq \Lock$ or 										\\
				$\getNextLock(\lid_i) \neq \bot$ then abort								\\
				if \textcolor{blue}{$k \neq v$ or} $\validateTrapdoors
				((\lid_1,\ldots,\lid_k),(\td_1,\ldots,\td_v)) = \bot$ then abort			\\
				$\forall i \in [1,k]$: 													\\
				\quad $\updateStatus(\lid_i, \Rel)$										\\
				\quad send$_\smt$ $(\sid, \lid_i, \Rel)$ to $\getLeft(\lid_i)$ and $\sdv$
			}
		\end{minipage}
		\begin{minipage}[t]{0.45\textwidth}
			\procedure[mode=text]{$\Lock(\sid, (\lid_1,\ldots,\lid_k), 
				\{(U_{j_1},p_{j_1}),\ldots,(U_{j_m},p_{j_m})\})$}{
				Upon invocation by $U_i$: 													\\
				$\forall j \in [1,k]$: if $U_i \neq U_0$ and $\getStatus(\lid_j) \neq 
				\Lock$ and $\getRight(\lid_j) \neq U_i$ the abort							\\
				\textcolor{blue}{if $\sum_{i=1}^m p_{j_i} > k$ then abort}					\\
				set $\ell = (\lid_1,\ldots,\lid_k)$											\\
				$\forall e \in [1,m]$:														\\
				\quad $\forall a \in [1,p_{j_e}]$:											\\
				\qquad $\lid' \sample \{0,1\}^{\lambda}$										\\
				\qquad sample $\lid^* \sample \ell$ and set $\ell = \ell \setminus 
				\{\lid^*\}$																	\\
				\qquad if $U_i = U_0$: 														\\
				\qquad \quad $\setRightUser(\lid^*, U_{j_e})$								\\
				\qquad \quad set $\lid' = \lid^*$											\\
				\qquad else: 																\\
				\qquad \quad insert $(\lid', \bot, U_i, U_{j_e}, \Init, \bot)$ into $\LL$	\\
				\qquad \quad $\setRightLock(\lid^*, \lid')$									\\
				\qquad send$_\smt$ $(\sid, \lid', \Lock)$ to $\getRight(\lid')$ and $\sdv$	\\
				\qquad receive$_\smt$ $(\sid, b)$ from $\getRight(\lid')$					\\
				\qquad if $b = \bot$ then send$_\smt$ $(\sid, \getRight(\lid'), \bot)$ 
				to $U_i$	 and $\sdv$															\\
				\qquad else:																	\\
				\qquad \quad $\updateStatus(\lid', \Lock)$									\\
				\qquad \quad send$_\smt$ $(\sid, \lid', \Lock)$ to $U_i, \getRight(\lid')$ and 
				$\sdv$
			}
			\\
			\procedure[mode=text]{$\mathsf{GetStatus}(\sid, \lid)$}{
				Upon invocation by $U_i$:												\\
				%if $\getLeft(\lid) \neq U_i$ or $\getRight(\lid) \neq U_i$ then abort	\\
				send$_\smt$ $(\sid, \lid, \getStatus(\lid))$ to $U_i$
			}
		\end{minipage}
	}
	
	\caption{Ideal functionality $\FF_{\mathsf{MPMHL}}$ in $(\FF_{\anon}, \FF_{\smt}, \FF_{\syn})$-hybrid model.}
	\label{fig:ideal-mpmhl}
\end{figure*}

\subsubsection{Discussion}
\label{sec:mpmhl-discussion}

We define the security and privacy notions of interest for {\sysname}s, and describe how they 
are captured by the functionality $\FF_{\mathsf{MPMHL}}$.

\TODOP{Add ACID properties.}

\paragraph{Consistency} A \sysname is consistent if no user can release its left lock without its 
right lock being released first. Our ideal functionality captures this property as the $\Release$ 
interface allows a user to release the left lock only if the corresponding right lock has already 
been released. In case the user is the receiver, the $\Extract$ interface is used for releasing, 
and it makes sure that there are no further right locks before starting the release of the 
provided locks.

\MESSAGEE{But in our actual protocol we have a wormhole attack, so consistency should not 
quite hold. Need to get rid of this, and modify the ideal functionality accordingly.}

\paragraph{Atomicity} Atomicity means that every user in any path is able to release its left 
lock only if the corresponding right lock is already released. Our ideal functionality enforces 
this by keeping track of all the locks in the list $\LL$, and in the $\Release$ interface only 
changes the status of a lock to $\Rel$ if the corresponding next lock is already released (i.e., 
has flag $\Rel$). If the user is the receiver, then the $\Extract$ interface validates that no 
right lock exists.

\paragraph{Completeness} A \sysname is complete if the receiver can only start releasing its 
locks, once it has received same number of locks as the trapdoors (i.e., the receiver has 
received all the locks intended for him). More precisely, our ideal functionality generates 
$v$ trapdoors in the $\Setup$ interface, and in the $\Extract$ interface the release can only 
begin if the receiver has $v$ locks as well.

\paragraph{Relationship Anonymity} Relationship anonymity requires that each intermediate user 
cannot distinguish two simultaneous multi-hop locks with the same sender and receiver. This is 
achieved by our ideal functionality as the lock identifiers are sampled at random, and during 
the locking phase a user only learns the identifiers of its left and right locks. Since the 
identifiers are independent the property follows.

\MESSAGEE{In our protocols we only achieve relationship anonymity as long as one intermediary is 
honest. And what about anonymity in the sense that a user cannot distinguish if it is part of a 
single-path or multi-path lock?}
