\section{Protocol}

\TODOE{Building blocks}

\subsection{Intuition}

We provide two constructions, namely single-trapdoor and multi-trapdoor. The main difference 
between the two is that in the single-trapdoor construction only a single trapdoor is used, and 
no matter the number of locks the receiver gets, all of them can be released using the same 
trapdoor. Hence, the receiver is not forced to wait to receive all the locks intended for him. 
Whereas in the multi-trapdoor construction we generate as many lock/trapdoor pairs as the amount 
of coins the sender wants to transfer to the receiver. This means that if the sender wants to 
send $v$ coins, then he generates $v$ lock/trapdoor pairs, hence, every lock has a unique 
trapdoor associated to it. Although, from a communication perspective multi-trapdoor 
construction is more expensive compared to the single-trapdoor construction, it has a feature 
that allows us to force the receiver to wait for all (or threshold of) the $v$ locks intended for 
him, before starting the release of the locks. This feature is achieved as follows: the sender 
generates $v$ lock/trapdoor pairs, and two encryption keys $k_s, k_t$, encrypts the trapdoors 
using the key $k_t$ (therefore, creating a ciphertext $c_t$), secret shares the key $k_t$ into 
$v$ shares ($[k_t]_1,\ldots,[k_t]_v$), encrypts all these shares individually using the key $k_s$ 
(therefore, creating $v$ ciphertexts $(c_s^{(1)},\ldots,c_s^{(v)})$), includes these ciphertexts 
inside the $v$ locks that it previously created (one ciphertext per lock), and sends $c_t$ and 
$k_s$ to the receiver. At this point the receiver has the key $k_s$, which can be used to decrypt 
the share ciphertexts $(c_s^{(1)},\ldots,c_s^{(v)})$, however, he doesn't have the key $k_t$, 
which will allow him to decrypt the ciphertext $c_t$ that includes the trapdoors he needs 
to release the locks. Since the share ciphertexts $(c_s^{(1)},\ldots,c_s^{(v)})$ are now part of 
the locks, they will eventually reach the receiver, and at that point the receiver can use the 
key $k_s$ it received from the sender to decrypt these ciphertexts, and obtain the shares $
[k_t]_1,\ldots,[k_t]_v$ of the key $k_t$. 
Once the receiver obtains these shares, he can reconstruct the key $k_t$, and decrypt the 
ciphertext $c_t$ to obtain the trapdoors of the locks, and start releasing the locks. Hence, the 
receiver needs to wait for all the $v$ locks to reach him, so that he can decrypt all the 
ciphertexts that are part of the locks and reconstruct the key $k_t$. Instead of forcing the 
receiver to wait for all the $v$ locks, we can also force him to wait for a subset of size $t$ of 
them using a $t$-out-of-$v$ secret sharing. The locking and releasing mechanisms are identical in 
both the single-trapdoor and multi-trapdoor constructions, and are based on pairings. 
The differences between the two constructions are how the setup is performed by the sender, and 
how the release of the locks from receiver (extraction phase) happens.

\subsection{Cryptographic Building Blocks}

\paragraph{Bilinear Groups} Let $\BilGen$ be a $\ppt$ algorithm that on input a security 
parameter $1^\lambda$ outputs $(q, e, \GG_1, \GG_2, \GG_T, g_1, g_2, g_T) \gets 
\BilGen(1^\lambda)$, where $\GG_1, \GG_2$ and $\GG_T$ are groups of prime order $q$ with 
bilinear map $e \colon \GG_1 \times \GG_2 \to \GG_T$, and generators $g_i \in \GG_i$ for $i \in 
\{1,2,T\}$. We consider Type-III bilinear groups as they represent the state-of-the-art regarding 
the efficiency and security.

\paragraph{Universal Re-encryption Scheme} Universal re-encryption allows to re-encrypt without 
knowledge of the public key under which a ciphertext was computed. Therefore, one can use it to 
re-randomize an input ciphertext, such that the encrypted value remains the same, but the output 
ciphertext looks different than the input ciphertext. Universal re-encryption scheme is composed 
of the algorithms $(\kgen, \enc, \dec, \renc)$, where $(\sk, \pk) \gets \kgen(1^\lambda)$, 
$c \gets \enc(\pk, m)$, $m \gets \dec(\sk, c)$, and $c' \gets \renc(c)$, for a secret/public key 
pair $(\sk, \pk)$, a message $m$, a ciphertext $c$, and a randomized ciphertext $c'$. 
Golle et al. \cite{gjjs} showed how to build such a primitive using the ElGamal encryption 
scheme. This is achieved by appending to a standard ElGamal ciphertext a second ciphertext on 
the identity element. Since ElGamal is homomorphic, one can use the second ciphertext to alter 
the encryption factor in the first ciphertext. Hence, one does not need knowledge of the public 
key in the re-encryption operation. The scheme of Golle et al. is defined as follows. $\kgen$ on 
input the security parameter $1^\lambda$, samples a random $x \sample \ZZ_q$, computes $y \gets 
g^x$, and outputs $\sk := x, \pk := y$. $\enc$ on input a message $m$ and a public key $y$, 
samples a random encryption factor $r := (k_0, k_1) \sample \ZZ_q^2$, and outputs 
$c := [(\alpha_0,\beta_0);(\alpha_1,\beta_1)] := [(my^{k_0},g^{k_0});(y^{k_1},g^{k_1})]$. $\dec$ 
on input a secret key $x$ and a ciphertext $c := [(\alpha_0,\beta_0);(\alpha_1,\beta_1)]$, 
computes $m_0 \gets \alpha_0 / \beta_0^x$ and $m_1 \gets \alpha_1 / \beta_1^x$. If $m_1 = 1$, 
then it outputs $m := m_0$. Otherwise, the decryption fails, and it outputs $\bot$. $\renc$ on 
input a ciphertext $c := [(\alpha_0,\beta_0); (\alpha_1,\beta_1)]$, samples a random 
re-encryption factor $r' := (k_0',k_1') \sample \ZZ_q^2$, and outputs a randomized ciphertext 
$c' := [(\alpha_0',\beta_0');(\alpha_1',\beta_1')] := [(\alpha_0\alpha_1^{k_0'},
\beta_0\beta_1^{k_0'});(\alpha_1^{k_1'},\beta_1^{k_1'})]$.

\subsection{PCN Construction}

\begin{figure*}[tb]
\centering
\fbox{\procedure{}{
	\< \mathsf{lock}_{U_i}(m): \< \\[][\hline]
	\< \text{Parse } m \text{ as } (\vec{s},\{(\cid_i^1, U_i^1,v_i^1,t_i^1),\ldots,(\cid_i^{k_i}, U_i^{k_i},v_i^{k_i},t_i^{k_i})\}) \< \\ [-0.15\baselineskip][]
	\< \text{Initialize } \vec{w} = \emptyset \< \\ [-0.15\baselineskip][]
	\< \pcfor j \pcin \{1..k_i\} \pcdo \< \\ [-0.15\baselineskip][]
	\< \pcind \text{Query } \FF_{\GC} \text{ on } (\mathsf{get}\mathsf{-channel},\cid_i^j) \< \\ [-0.15\baselineskip][]
	\< \pcind \text{Receive } \gamma_j \text{ from } \FF_{\GC} \< \\ [-0.15\baselineskip][]
	\< \pcind \pcif \gamma_j = \bot \textbf{ or } \gamma_j.\cash < v_i^j \pcthen \< \\ [-0.15\baselineskip][]
	\< \pcind \pcind \pcreturn \bot \< \\ [-0.15\baselineskip][] 
	\< \pcind \pcelse \< \\ [-0.15\baselineskip][] 
	\< \pcind \pcind \text{Query } \FF_{\mathsf{MPMHL}} \text{ on } (\mathsf{lock},\vec{s},U_i^j,v_i^j,t_i^j) \< \\ [-0.15\baselineskip][]
	\< \pcind \pcind \text{Receive } (\vec{w}_i^j,\vec{s}_i^j) \text{ from } \FF_{\mathsf{MPMHL}} \< \\ [-0.15\baselineskip][]
	\< \pcind \pcind \pcif \vec{w}_i^j = \bot \textbf{ or } \vec{s}_i^j = \bot \pcthen \< \\ [-0.15\baselineskip][]
	\< \pcind \pcind \pcind \pcreturn \bot \< \\ [-0.15\baselineskip][]
	\< \pcind \pcind \MESSAGEE{Update channel capacity here.} \< \\[-0.15\baselineskip][]
	\< \pcind \pcind \text{Set } \vec{w} = \vec{w} \cup \vec{w}_i^j \< \\ [-0.15\baselineskip][]
	\< \pcind \pcind \text{Send } (\mathsf{lock},U_i,(\vec{s}_i^j,v_i^j)) \text{ to } U_i^j \< \\ [-0.15\baselineskip][]
	\< \pcreturn \vec{w} \<
}}

\caption{The $\mathsf{lock}$ auxiliary function.}
\label{fig:mppcn-sender}
\end{figure*}


\begin{figure*}[tb]
\centering
\fbox{\procedure{}{
	\< \mathsf{pay}_{U_s}(m): \< \\[][\hline]
	\< \text{Parse } m \text{ as } (v, U_r,\{(\cid_s^1, U_s^1,v_s^1,t_s^1),\ldots,(\cid_s^{k_s}, U_s^{k_s},v_s^{k_s},t_s^{k_s})\}) \< \\ [-0.15\baselineskip][]
	\< \text{Query } \FF_{\mathsf{MPMHL}} \text{ on } (\mathsf{setup},v,U_r) \< \\ [-0.15\baselineskip][]
	\< \text{Receive } (\vec{\td}, \vec{s}) \text{ from } \FF_{\mathsf{MPMHL}} \< \\ [-0.15\baselineskip][]
	\< \text{Send } (\mathsf{setup}, U_s, \vec{\td}) \text{ to } U_r \< \\ [-0.15\baselineskip][]
	\< \text{Compute } \vec{w}_s \gets \mathsf{lock}_{U_s}((\vec{s},\{(\cid_s^1, U_s^1,v_s^1,t_s^1),\ldots,(\cid_s^{k_s}, U_s^{k_s},v_s^{k_s},t_s^{k_s})\})) \< \\ [-0.15\baselineskip][]
	\< \pcif \vec{w}_s = \bot \pcthen \< \\ [-0.15\baselineskip][]
	\< \pcind \pcabort \< \\ [-0.15\baselineskip][]
	\< \text{Store } \vec{w}_s
}}

\caption{The $\mathsf{pay}$ routine in MPPCN for the sender.}
\label{fig:mppcn-sender}
\end{figure*}

\begin{figure*}[tb]
\centering
\fbox{\procedure{}{
	\< \mathsf{pay}_{U_r}(m): \< \\[][\hline]
	\< \text{Parse } m \text{ as } (\textit{operation}, U^*, m^*) \< \\ [-0.15\baselineskip][]
	\< \pcif \textit{operation} = \mathsf{setup} \pcthen \< \\ [-0.15\baselineskip][]
	\< \pcind \text{Parse } m^* \text{ as } \vec{\td} \text{ and store } \vec{\td} \< \\ [-0.15\baselineskip][]
	\< \pcelse \pcif \textit{operation} = \mathsf{lock} \textbf{ and } \text{has stored } \vec{\td} \pcthen \< \\ [-0.15\baselineskip][]
	\< \pcind \text{Parse } m^* \text{ as } \vec{s} \< \\ [-0.15\baselineskip][]
	\< \pcind \text{Query } \FF_{\mathsf{MPMHL}} \text{ on } (\mathsf{extract},\vec{s},\vec{\td}) \< \\ [-0.15\baselineskip][]
	\< \pcind \text{Receive } \vec{k} \text{ from } \FF_{\mathsf{MPMHL}} \< \\ [-0.15\baselineskip][]
	\< \pcind \pcif \vec{k} = \bot \pcthen \< \\ [-0.15\baselineskip][]
	\< \pcind \pcind \pcabort \< \\ [-0.15\baselineskip][]
	\< \pcind \text{Send } (\mathsf{release},\vec{k}) \text{ to } U^* \< \\ [-0.15\baselineskip][]
	\< \pcelse \< \\ [-0.15\baselineskip][]
	\< \pcind \text{Send } (\mathsf{abort}, \bot) \text{ to } U^* \< \\ [-0.15\baselineskip][]
	\< \pcind \pcabort \< 
}}

\caption{The $\mathsf{pay}$ routine in MPPCN for the receiver.}
\label{fig:mppcn-receiver}
\end{figure*}

\begin{figure*}[tb]
\centering
\fbox{\procedure{}{
	\< \mathsf{pay}_{U_i}(m): \< \\[][\hline]
	\< \text{Parse } m \text{ as } (\textit{operation}, U^*, m^*) \< \\ [-0.15\baselineskip][]
	\< \pcif \textit{operation} = \mathsf{lock} \pcthen \< \\ [-0.15\baselineskip][]
	\< \pcind \text{Parse } m^* \text{ as } (\vec{s}_i,v_i) \< \\ [-0.15\baselineskip][]
	\< \pcind \text{Query } \MESSAGEE{routing ideal functionality} \text{ on } (\mathsf{get}\mathsf{-split},\vec{s}_i,v_i) \< \\ [-0.15\baselineskip][]
	\< \pcind \text{Receive } \{(\cid_i^1, U_i^1,v_i^1,t_i^1),\ldots,(\cid_i^{k_i}, U_i^{k_i},v_i^{k_i},t_i^{k_i})\} \text{ from } \MESSAGEE{routing ideal functionality} \< \\ [-0.15\baselineskip][]
	\< \pcind \text{Compute } \vec{w} \gets \mathsf{lock}_{U_i}((\vec{s},\{(\cid_i^1, U_i^1,v_i^1,t_i^1),\ldots,(\cid_i^{k_i}, U_i^{k_i},v_i^{k_i},t_i^{k_i})\})) \< \\ [-0.15\baselineskip][]
	\< \pcind \pcif \vec{w} = \bot \pcthen \< \\ [-0.15\baselineskip][]
	\< \pcind \pcind \pcabort \< \\ [-0.15\baselineskip][]
	\< \pcind \text{Set } \vec{w}_i = \vec{w}_i \cup \vec{w} \< \\ [-0.15\baselineskip][]
	\< \pcind \text{Set } \mathcal{L} = \mathcal{L} \cup \{U^*\} \text{ and } \mathcal{R} = \mathcal{R} \cup \{U_i^1,\ldots,U_i^{k_i}\}  \< \\ [-0.15\baselineskip][]
	\< \pcelse \pcif \textit{operation} = \mathsf{release} \pcthen \< \\ [-0.15\baselineskip][]
	\< \pcind \text{Parse } m^* \text{ as } \vec{k} \< \\ [-0.15\baselineskip][]
	\< \pcind \text{Query } \FF_{\mathsf{MPMHL}} \text{ on } (\mathsf{release},\vec{k},\vec{w}_i) \< \\ [-0.15\baselineskip][]
	\< \pcind \text{Receive } \vec{k}_i \text{ from } \FF_{\mathsf{MPMHL}} \< \\ [-0.15\baselineskip][]
	\< \pcind \pcif \vec{k}_i = \bot \pcthen \< \\ [-0.15\baselineskip][]
	\< \pcind \pcind \pcabort \< \\ [-0.15\baselineskip][]
	\< \pcind \text{Send } (\mathsf{release},\vec{k}_i) \text{ to every user in } \mathcal{L} \< \\ [-0.15\baselineskip][]
	\< \pcelse \pcif \textit{operation} = \mathsf{abort} \pcthen \< \\ [-0.15\baselineskip][]
	\< \pcind \text{Send } (\mathsf{abort},\bot) \text{ to every user in } \mathcal{L} \< \\ [-0.15\baselineskip][]
	\< \pcind \pcabort
}}

\caption{The $\mathsf{pay}$ routine in MPPCN for the intermediary.}
\label{fig:mppcn-intermediary}
\end{figure*}

\subsection{Single-Trapdoor Construction}

\begin{figure*}[htb]
	\begin{center}
	\framebox[0.78\textwidth]{
		\begin{minipage}[t]{0.75\textwidth}
			\underline{{$\langle \Setup_{U_0}(1^\lambda, U_n), \Setup_{U_n}(1^\lambda) \rangle$}}: 
			On input the security parameter $1^\lambda$, a user identifier $U_n$, 
			obtain the public parameters $(q, e, \GG_1, \GG_2, \GG_T, g_1, g_2, g_T) \gets \BilGen(1^\lambda)$,
			sample $(x,y) \sample \ZZ_q^2$, compute the state $s_0 \gets (g_1^{xy}, g_T^y)$, send 
			$\vec{\td} := (x)$ to $U_n$ and return $\vec{s} := (s_0)$ to $U_0$. \\
			\underline{$\langle \Lock_{U_i}(\vec{s}, \{(U_{j_1},p_{j_1}),\ldots,(U_{j_m},p_{j_m})\}), 
			\Lock_{U_{j_1}}(), \ldots, \Lock_{U_{j_m}}() \rangle$}: On input a vector of states  
			$\vec{s}$, a set of tuples $\{(U_{j_1},p_{j_1}),\ldots,(U_{j_m},p_{j_m})\}$, 
			where $U_{j_i}$ is a user identifier and $p_{j_i}$ is the corresponding partition size, 
			$\forall e$ in $[1,m]$, sample a random $r_e \sample \ZZ_q$, pick $p_{j_e}$ many states 
			$(s_1,\ldots,s_{p_{j_e}})$ from $\vec{s}$, $\forall a$ in $[1,p_{j_e}]$, parse state $s_a$ 
			as $(s_a^{(1)},s_a^{(2)})$, set $s_a^\dag \gets ((s_a^{(1)})^{r_e}, (s_a^{(2)})^{r_e})$. Finally, 
			send $\vec{s}^\dag := (s_1^\dag,\ldots,s_{p_{j_e}}^\dag)$ to $U_{j_e}$, and store 
			$\vec{w} := (r_1,\ldots,r_m)$. \\
			\underline{$\Extract(\vec{s}, \vec{\td})$}: On input a vector of states $\vec{s} := (s_1,
			\ldots,s_l)$, a vector of trapdoors $\vec{\td} := (x)$, $\forall i$ in $[1,l]$, parse $s_i$ as 
			$(s_i^{(1)}, s_i^{(2)})$, check whether $e((s_i^{(1)})^{x^{-1}}, g_2) \? s_i^{(2)}$. If the 
			check passes, set $k_i = (s_i^{(1)})^{x^{-1}}$, otherwise return $\bot$. Finally, return 
			$\vec{k} := (k_1,\ldots,k_l)$. \\
			\underline{$\Release(\vec{k}, \vec{w})$}: On input a vector of keys $\vec{k} := (k_1,\ldots,k_l)$, 
			and a vector of witnesses $\vec{w} := (r_1,\ldots,r_l)$, $\forall i$ in $[1,l]$, set $k_i' \gets 
			(k_i)^{{r_i}^{-1}}$, and return $\vec{k'} := (k_1',\ldots,k_l')$. \\
			\underline{$\Verify(\vec{s}, \vec{k})$}: On input a vector of states $\vec{s} := (s_1,\ldots,
			s_l)$ and a vector of keys $\vec{k} := (k_1,\ldots,k_l)$, return 1 if $\forall i \in [1,l]$, 
			parse $s_i$ as $(s_i^{(1)}, s_i^{(2)})$ and $e(k_i, g_2) \? s_i^{(2)}$ holds, and 
			0 otherwise.
		\end{minipage}
	}
	\end{center}
	
	\caption{Algorithms and protocols for the single trapdoor construction.}
	\label{fig:single-trapdoor}
\end{figure*}

%\MESSAGEE{Can an intermediary have unequal number of states, keys and witnesses for $\Extract$?}

\subsection{Multi-Trapdoor Construction}

\begin{figure*}[htb]
	\begin{center}
	\framebox[0.78\textwidth]{
		\begin{minipage}[t]{0.75\textwidth}
			\underline{$\langle \Setup_{U_0}(1^\lambda, v, U_n), \Setup_{U_n}(1^\lambda) \rangle$}: 
			On input the security parameter $1^\lambda$, a payment value $v$ and a user identifier $U_n$, 
			obtain the public parameters $(q, e, \GG_1, \GG_2, \GG_T, g_1, g_2, g_T) \gets \BilGen(1^\lambda)$,
			sample $(x_1,\ldots,x_v,y) \sample \ZZ_q^{v+1}$, $(\sk_t, \pk_t) \sample \kgen(1^\lambda)$ and 
			$(\sk_s, \pk_s) \sample \kgen(1^\lambda)$, secret share $\sk_t$ as $([\sk_t]_1,\ldots[\sk_t]_v)$, 
			compute the ciphertexts $c_t \gets \enc(\pk_t, x_1 \concat\cdots\concat x_v)$ and $(c_s^{(1)},
			\ldots,c_s^{(v)}) \gets (\enc(\pk_s, [\sk_t]_1),\ldots,\enc(\pk_s, [\sk_t]_v))$, compute the states 
			$(s_1,\ldots,s_v) \gets ((g_1^{x_1y},g_T^y, c_s^{(1)}),\ldots,(g_1^{x_vy}, g_T^y, c_s^{(v)}))$, send 
			$\vec{\td} := ((\sk_s,\pk_s), c_t, v)$ to $U_n$, and return $\vec{s} := (s_1,\ldots,s_v)$ to 
			$U_0$. \\
			\underline{$\langle \Lock_{U_i}(\vec{s}, \{(U_{j_1},p_{j_1}),\ldots,(U_{j_m},p_{j_m})\}), 
			\Lock_{U_{j_1}}(), \ldots, \Lock_{U_{j_m}}() \rangle$}: On input a vector of states  
			$\vec{s} := (s_1,\ldots,s_l)$, a set of tuples $\{(U_{j_1},p_{j_1}),\ldots,(U_{j_m},p_{j_m})\}$, 
			where $U_{j_i}$ is a user identifier and $p_{j_i}$ is the corresponding partition size, 
			$\forall e$ in $[1,m]$, sample a random $r_e \sample \ZZ_q$, pick $p_{j_e}$ many unused 
			states $(s_1,\ldots,s_{p_{j_e}})$ from $\vec{s}$, $\forall a$ in $[1,p_{j_e}]$, parse state $s_a$ 
			as $(s_a^{(1)},s_a^{(2)},s_a^{(3)})$, set $s_a^\dag \gets ((s_a^{(1)})^{r_e}, (s_a^{(2)})^{r_e}, 
			\renc(s_a^{(3)}))$. Finally, send $\vec{s}^\dag := (s_1^\dag,\ldots,s_{p_{j_e}}^\dag)$ to 
			$U_{j_e}$, and store $\vec{w} := (r_1,\ldots,r_m)$. \\
			\underline{$\Extract(\vec{s}, \vec{\td})$}: On input a vector of states  
			$\vec{s} := (s_1,\ldots,s_l)$, a vector of trapdoors $\vec{td} := ((\sk_s,\pk_s), c_t, v)$, 
			if $l \neq v$, then return $\bot$. Otherwise, $\forall i$ in $[1,l]$, parse $s_i$ as 
			$(s_i^{(1)}, s_i^{(2)}, s_i^{(3)})$ and decrypt to obtain $[\sk_t]_i \gets 
			\dec(\sk_s, s_i^{(3)})$. If any $[\sk_t]_i = \bot$, then return $\bot$, else reconstruct 
			$\sk_t$ from $([\sk_t]_1,\ldots,[\sk_t]_v)$. Compute $x \gets \dec(\sk_t, c_t)$, if $x = \bot$, then 
			return $\bot$, otherwise, parse $x$ as $(x_1,\ldots,x_v)$, $\forall i$ in $[1,v]$ check whether 
			$e((s_i^{(1)})^{{x_i}^{-1}}, g_2) \? s_i^{(2)}$. If the check passes, set 
			$k_i \gets (s_i^{(1)})^{{x_i}^{-1}}$, otherwise return $\bot$. Finally, return $\vec{k} := 
			(k_1,\ldots,k_l)$. \\
			\underline{$\Release(\vec{k}, \vec{w})$}: On input a vector of keys $\vec{k} := (k_1,\ldots,k_l)$, 
			and a vector of witnesses $\vec{w} := (r_1,\ldots,r_l)$, $\forall i$ in $[1,l]$, set $k_i' \gets 
			(k_i)^{{r_i}^{-1}}$, and return $\vec{k'} := (k_1',\ldots,k_l')$. \\
			\underline{$\Verify(\vec{s}, \vec{k})$}: On input a vector of states $\vec{s} := (s_1,\ldots,
			s_l)$ and a vector of keys $\vec{k} := (k_1,\ldots,k_l)$, return 1 if $\forall i \in [1,l]$, 
			parse $s_i$ as $(s_i^{(1)}, s_i^{(2)}, s_i^{(3)})$ and $e(k_i, g_2) \? s_i^{(2)}$ holds, and 
			0 otherwise.
		\end{minipage}
	}
	\end{center}
	
	\caption{Algorithms and protocols for the multiple trapdoor construction.}
	\label{fig:multi-trapdoor}
\end{figure*}
