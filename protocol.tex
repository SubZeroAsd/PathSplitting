\section{Protocol}

\TODOE{Building blocks}

\TODOE{Overview}

\subsection{Intuition}

\subsection{Cryptographic Building Blocks}

\paragraph{Bilinear Groups} Let $\BilGen$ be a $\ppt$ algorithm that on input a security 
parameter $1^\lambda$ outputs $(q, e, \GG_1, \GG_2, \GG_T, g_1, g_2, g_T) \gets \BilGen
(1^\lambda)$, where $\GG_1, \GG_2$ and $\GG_T$ are groups of prime order $q$ with bilinear 
map $e \colon \GG_1 \times \GG_2 \to \GG_T$, and generators $g_i \in \GG_i$ for $i \in \{1,2,T\}$.
We consider Type-III bilinear groups as they represent the state-of-the-art regarding the 
efficiency and security.

\paragraph{Randomizable Encryption Scheme} 

\MESSAGEE{We need an encryption scheme that allows to re-randomize a given ciphertext, such that the 
encrypted value remains the same, however the output ciphertext looks different than the input 
ciphertext. Furthermore, we need to assure that this operation can be performed without access to a 
secret/public key.}

\subsection{Single-Trapdoor Construction}

\begin{figure*}[htb]
	\begin{center}
	\framebox[0.78\textwidth]{
		\begin{minipage}[t]{0.75\textwidth}
			\underline{{$\langle \Setup_{U_0}(1^\lambda, U_n), \Setup_{U_n}(1^\lambda) \rangle$}}: 
			On input the security parameter $1^\lambda$, a user identifier $U_n$, sample $(x,y) \sample 
			\ZZ_q^2$, compute the state $s_1 \gets (g_1^{xy}, g_T^y)$, send $\vec{\td} := (x)$ to $U_n$ 
			and return $\vec{s} := (s_1)$. \\
			\underline{$\langle \Lock_{U_i}(\vec{s}, \{(U_{j_1},p_{j_1}),\ldots,(U_{j_m},p_{j_m})\}), 
			\Lock_{U_{j_1}}(), \ldots, \Lock_{U_{j_m}}() \rangle$}: On input a vector of states  
			$\vec{s} := (s_1,\ldots,s_l)$, a set of tuples $\{(U_{j_1},p_{j_1}),\ldots,(U_{j_m},p_{j_m})\}$, 
			where $U_{j_i}$ is a user identifier and $p_{j_i}$ is the corresponding partition size, 
			$\forall e$ in $[1,m]$, sample a randomness $r_e \sample \ZZ_q$, pick $p_{j_e}$ many states 
			$(s_1,\ldots,s_{p_{j_e}})$ from $\vec{s}$, $\forall a$ in $[1,p_{j_e}]$, parse state $s_a$ 
			as $(s_a^{(1)},s_a^{(2)})$, set $\ell_a \gets (s_a^{(2)})^r, s_a^\dag \gets 
			((s_a^{(1)})^r, \ell_a)$. Finally, send $\vec{s}^\dag := (s_1^\dag,\ldots,
			s_{p_{j_e}}^\dag)$ to $U_{j_e}$, and store $\vec{w} := (r_1,\ldots,r_m)$. \\
			\underline{$\Extract(\vec{s}, \vec{\td})$}: On input a vector of states $\vec{s} := (s_1,
			\ldots,s_l)$, a vector of trapdoors $\vec{\td} := (x)$, $\forall i$ in $[1,l]$, parse $s_i$ as 
			$(s_i^{(1)}, s_i^{(2)})$, check whether $e((s_i^{(1)})^{x^{-1}}, g_2) \? s_i^{(2)}$. If the 
			check passes, set $k_i = (s_i^{(1)})^{x^{-1}}$, otherwise return $\bot$. Finally, return 
			$\vec{k} := (k_1,\ldots,k_l)$. \\
			\underline{$\Release(\vec{k}, \vec{w})$}: On input a vector of keys $\vec{k} := (k_1,\ldots,k_l)$, 
			and a vector of witnesses $\vec{w} := (r_1,\ldots,r_l)$, $\forall i$ in $[1,l]$, set $k_i' \gets 
			(k_i)^{{r_i}^{-1}}$, and return $\vec{k'} := (k_1',\ldots,k_l')$. \\
			\underline{$\Verify(\vec{s}, \vec{k})$}: On input a vector of states $\vec{s} := (s_1,\ldots,
			s_l)$ and a vector of keys $\vec{k} := (k_1,\ldots,k_l)$, return 1 if $\forall i \in [1,l]$, 
			parse $s_i := (s_i^{(1)}, s_i^{(2)})$ and $e(k_i, g_2) \? s_i^{(2)}$ holds, and 
			0 otherwise.
		\end{minipage}
	}
	\end{center}
	
	\caption{Algorithms and protocols for the single trapdoor construction.}
	\label{fig:single-trapdoor}
\end{figure*}

\MESSAGEE{Can an intermediary have unequal number of states, keys and witnesses for $\Extract$?}

\subsection{Multi-Trapdoor Construction}

\begin{figure*}[htb]
	\begin{center}
	\framebox[0.78\textwidth]{
		\begin{minipage}[t]{0.75\textwidth}
			\underline{$\langle \Setup_{U_0}(1^\lambda, v, U_n), \Setup_{U_n}(1^\lambda) \rangle$}: 
			On input the security parameter $1^\lambda$, a payment value $v$ and a user identifier $U_n$, 
			sample $(x_1,\ldots,x_v,y) \sample \ZZ_q^{v+1}$ and $k_t, k_s \sample \mathcal{K}$, secret 
			share $k_t$ as $([k_t]_1,\ldots[k_t]_v)$, generate ciphertexts $(c_t^{(1)},\ldots,c_t^{(v)}) \gets 
			(\enc(k_t, x_1),\ldots,\enc(k_t,x_v))$ and $(c_s^{(1)},\ldots,c_s^{(v)}) \gets (\enc(k_s, 
			[k_t]_1),\ldots, \enc(k_s, [k_t]_v))$, compute the states $(s_1,\ldots,s_v) \gets ((g_1^{x_1y}, 
			g_T^y, c_s^{(1)}),\ldots,(g_1^{x_vy}, g_T^y, c_s^{(v)}))$, send 
			$\vec{\td} := (k_s, (c_t^{(1)},\ldots,c_t^{(v)}))$ to $U_n$, and return 
			$\vec{s} := (s_1,\ldots,s_v)$. \\
			\underline{$\langle \Lock_{U_i}(\vec{s}, \{(U_{j_1},p_{j_1}),\ldots,(U_{j_m},p_{j_m})\}), 
			\Lock_{U_{j_1}}(), \ldots, \Lock_{U_{j_m}}() \rangle$}: On input a vector of states  
			$\vec{s} := (s_1,\ldots,s_l)$, a set of tuples $\{(U_{j_1},p_{j_1}),\ldots,(U_{j_m},p_{j_m})\}$, 
			where $U_{j_i}$ is a user identifier and $p_{j_i}$ is the corresponding partition size, 
			$\forall e$ in $[1,m]$, sample a randomness $r_e \sample \ZZ_q$, pick $p_{j_e}$ many unused 
			states $(s_1,\ldots,s_{p_{j_e}})$ from $\vec{s}$, $\forall a$ in $[1,p_{j_e}]$, parse state $s_a$ 
			as $(s_a^{(1)},s_a^{(2)},s_a^{(3)})$, set $\ell_a \gets (s_a^{(2)})^r, s_a^\dag \gets 
			((s_a^{(1)})^r, \ell_a, \rand(s_a^{(3)}))$. Finally, send $\vec{s}^\dag := (s_1^\dag,\ldots,
			s_{p_{j_e}}^\dag)$ to $U_{j_e}$, and store $\vec{w} := (r_1,\ldots,r_m)$. \\
			\underline{$\Extract(\vec{s}, \vec{\td})$}: On input a vector of states  
			$\vec{s} := (s_1,\ldots,s_l)$, a vector of trapdoors $\vec{td} := (k_s, (c_1,\ldots,c_v))$, 
			if $l \neq v$, then return $\bot$. Otherwise, $\forall i$ in $[1,l]$, parse $s_i$ as 
			$(s_i^{(1)}, s_i^{(2)}, s_i^{(3)})$, and decrypt to obtain $[k_t]_i \gets 
			\dec(k_s, s_i^{(3)})$. If any $[k_t]_i = \bot$, then return $\bot$, else reconstruct 
			$k_t$ from $([k_t]_1,\ldots,[k_t]_v)$. Then, $\forall i$ in $[1,v]$, decrypt 
			$x_i \gets \dec(k_t, c_i)$, if $x_i = \bot$, then return $\bot$, otherwise, 
			check whether $e((s_i^{(1)})^{{x_i}^{-1}}, g_2) \? s_i^{(2)}$. If the check passes, set 
			$k_i \gets (s_i^{(1)})^{{x_i}^{-1}}$, otherwise return $\bot$. Finally, return $\vec{k} := 
			(k_1,\ldots,k_l)$. \\
			\underline{$\Release(\vec{k}, \vec{w})$}: On input a vector of keys $\vec{k} := (k_1,\ldots,k_l)$, 
			and a vector of witnesses $\vec{w} := (r_1,\ldots,r_l)$, $\forall i$ in $[1,l]$, set $k_i' \gets 
			(k_i)^{{r_i}^{-1}}$, and return $\vec{k'} := (k_1',\ldots,k_l')$. \\
			\underline{$\Verify(\vec{s}, \vec{k})$}: On input a vector of states $\vec{s} := (s_1,\ldots,
			s_l)$ and a vector of keys $\vec{k} := (k_1,\ldots,k_l)$, return 1 if $\forall i \in [1,l]$, 
			parse $s_i := (s_i^{(1)}, s_i^{(2)}, s_i^{(3)})$ and $e(k_i, g_2) \? s_i^{(2)}$ holds, and 
			0 otherwise.
		\end{minipage}
	}
	\end{center}
	
	\caption{Algorithms and protocols for the multiple trapdoor construction.}
	\label{fig:multi-trapdoor}
\end{figure*}
